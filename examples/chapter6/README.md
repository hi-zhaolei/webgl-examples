# GLSL ES

大小写敏感

每个语句以英文分号结束

必须有且仅有一个main()函数，并且该函数不能有返回值，必须指定返回值。

## 数据值类型

### 数值类型

GLSL ES支持整型数和浮点数

### 布尔值类型

GLSL ES支持布尔值类型，包括true false

## 变量

只能包括a-z,A-Z,0-9和下划线_

变量名不能以数字开头

不能以gl_,webgl_或_webgl_开头

不能是关键字

强类型语言，显式声明变量`<类型> <变量名>`

## 基本类型

|类型 | 描述|
|---|---|
|float | 单精度浮点数类型。|
|init | 整数型|
|bool | 布尔值|

###  赋值和类型转换

使用**=**赋值变量，值和变量类型必须相同，可以通过内置类型转换函数进行处理

| 转换 | 函数 | 描述|
|---|----|---|
| 转换为整数型 | init(float) | 将浮点数的消暑部分删去，转换为整数型|
| | init(bool) | true转换为1，false转换为0|
| 转换为浮点数 | float(init) | 将整数型转换为浮点数(补零)|
| | float(bool) | true转换为1.0，false转换为0.0|
| 转换为布尔值 | bool(init) | 0转换为false，其他为true|
| | bool(float) | 0.0转换为false，其他为true|

### 运算符

GLSL ES支持的运算类型与Javascript类似

进行与(&&)运算时，只有第一个表达式的计算值为true时才会计算第二个表达式。同样，或(||)运算只有第一个表达式为false才会计算第二个。

异或(^^)运算含义是，只有当左右两个表达式中有且仅有一个为true时，运算结果才是true

## 矢量与矩阵

GLSL ES支持矢量和矩阵。他们都包含多个元素，矢量可以表示顶点坐标或颜色值，矩阵用来表示变换矩阵。

| 类别 | GLSL ES数据类型 | 描述|
|---|-------------|---|
| 矢量 | vec2 vec3 vec4 | 具有2 3 4个浮点数元素的矢量|
| | ivec2 ivec3 ivec4 | 具有2 3 4个整型数元素的矢量|
| | bvec2 bvec3 bvec4 | 具有2 3 4个布尔值元素的矢量|
| 矩阵 | mat2 mat3 mat4 | 2\*2 3\*3 4\*4浮点数元素矩阵|

### 赋值和构造

使用=进行赋值操作，=左右两边的变量或值必须一致，矩阵元素个数也必须一致，可以使用内置的构造函数创建对应变量值

### 矢量构造函数

vec() vec2() vec3() vec4()

```
vec3 v3 = vec3(1.0, 0.0, 0.5); // 将v3设置为(1.0, 0.0, 0.5)
vec2 v2 = vec2(vec3); // 使用v3的前两个元素
vec4 v4 = vec4(1.0); // 将v4设置为(1.0, 1.0, 1.0, 1.0)
```
但是，如果构造函数接受了不止一个参数，但是数值参数的个数少于函数需求，那么就会报错。也可以使用多个矢量组合成一个矢量，规则是自前向后依次填充参数矢量的元素，直到填充满，之后截断。

### 矩阵构造函数

和矢量构造函数类似，但需要保证存储在矩阵中的元素是按照列主序排列的。

#### 元素构造

```
mat4 m4 = mat4(
  1.0, 2.0, 3.0, 4.0,
  5.0, 6.0, 7.0, 8.0,
  9.0, 10.0, 11.0, 12.0,
  13.0, 14.0, 15.0, 16.0,
)
// output:
// |1.0 5.0  9.0 13.0|
// |2.0 6.0 10.0 14.0|
// |3.0 7.0 11.0 15.0|
// |4.0 8.0 12.0 16.0|
```

#### 矢量构造

```
// 使用两个vec2对象创建mat2对象
vec2 v2_1 = vec2(1.0, 3.0);
vec2 v2_2 = vec2(2.0, 4.0);
mat2 m2 = mat2(v2_1, v2_2);
// output
// |1.0 2.0|
// |3.0 4.0|

// 使用vec4创建mat2
vec4 v4 = vec4(1.0, 2.0, 3.0, 4.0);
mat2 m2 = mat2(vec4);
// output
// |1.0 3.0|
// |2.0 4.0|
```

#### 混合构造(元素和矢量)

```
// 使用两个浮点数和vec2对象创建mat2
vec2 v2_2 = vec2(2.0, 4.0);
mat2 m2 = mat2(1.0, 3.0, v2_2);
// output
// |1.0 2.0|
// |3.0 4.0|
```

#### 单值构造

```
// 向矩阵构造函数中传入单个数据，这样将生成一个对角线上元素都是该数值，其他元素为0.0
mat2 m2 = mat2(1.0);
// output:
// |1.0 0.0 0.0 0.0|
// |0.0 1.0 0.0 0.0|
// |0.0 0.0 1.0 0.0|
// |0.0 0.0 0.0 1.0|
```

```
// 如果传入的数值数量大于1，又没有达到矩阵元素的数量，就会出错。
mat4 m4 = mat4(1.0, 2.0, 3.0); // 错误，mat4需要16个元素
```

### 访问元素

访问矢量和矩阵的元素，可以使用.和[]

#### 访问矢量元素

在矢量名后接[]运算符通过数组下标访问

在矢量名后接点（.）运算符，然后接上分量名。分量名有:

| 类别 | 描述 |
| --- | --- |
| x,y,z,w | 获取顶点坐标分量 |
| r,g,b,a | 获取颜色分量 |
| s,t,p,q | 获取纹理坐标分量 |

虽然矢量可以用来存储顶点坐标，颜色以及纹理坐标，但事实上，任何矢量的x r s都会返回第一个分量，以此类推，可以随意交换使用它们。

如果试图访问超过矢量长度的分量，会报错。

如果将多个分量共同至于点运算符后，可以抽取出多个分量。混合抽取时，可以省略分量，跳过分量，逆序，重复分量，使用全部分量

```
vec2 v2
v2 = v3.xy // v2为(1.0, 2.0)
v2 = v3.yz // v2为(2.0, 3.0)
```

聚合分量名也可以用=做赋值操作，会修改对应矢量元素

#### 访问矩阵

在矩阵名后接[]运算符通过数组下标访问，矩阵元素仍然是按照列主序读取，一个[]运算符读取矩阵列元素，读取列元素后再接[]运算符读取单个元素。

也可以[]和.运算符混合使用，[]运算符读取咧元素后可以使用上面矩阵分量方式读取单个元素

[]运算符中的索引值必须时常量索引值

1. 整型字面量

2. 用const修饰的全局变量或局部变量

3. 循环索引

4. 由前述三项组成的表达式

```
const init inde x = 0;
vec4 v4a = m4[index]; // 第2条
vec4 v4b = m4[index+1]; // 第4条
```

### 运算符

|运算符 | 运算 | 使用数据类型 |
| ----|----|------- |
| * | 乘法 | 适用于vec[234]和mat[234]，运算结果与操作数一置 |
| / | 除法 | 适用于vec[234]和mat[234]，运算结果与操作数一置 |
| + | 加法 | 适用于vec[234]和mat[234]，运算结果与操作数一置 |
| - | 减法 | 适用于vec[234]和mat[234]，运算结果与操作数一置 |
| ++ | 自增 | 适用于vec[234]和mat[234]，运算结果与操作数一置 |
| -- | 自减 | 适用于vec[234]和mat[234]，运算结果与操作数一置 |
| = | 赋值 | 适用于vec[234]和mat[234] |
| [+|-|*|/]= 运算赋值 | 适用于vec[234]和mat[234] |
| ==,!= | 比较 | 适用于vec[234]和mat[234]。对于==，如果两个操作数的每一个分量都相同，返回true；对于!=，如果两个操作数人和一个分量都不同，返回true |

对于矢量和矩阵，只可以使用比较运算符==和!=。比较矢量和矩阵的大小应该使用内置函数lessThan()等











