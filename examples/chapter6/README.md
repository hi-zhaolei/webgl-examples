# GLSL ES

大小写敏感

每个语句以英文分号结束

必须有且仅有一个main()函数，并且该函数必须指定返回值。

## 数据值类型

### 数值类型

GLSL ES支持整型数和浮点数

### 布尔值类型

GLSL ES支持布尔值类型，包括true false

## 变量

只能包括a-z,A-Z,0-9和下划线_

变量名不能以数字开头

不能以gl_,webgl_或_webgl_开头

不能是关键字

强类型语言，显式声明变量`<类型> <变量名>`

## 基本类型

|类型 | 描述|
|---|---|
|float | 单精度浮点数类型。|
|init | 整数型|
|bool | 布尔值|

###  赋值和类型转换

使用**=**赋值变量，值和变量类型必须相同，可以通过内置类型转换函数进行处理

| 转换 | 函数 | 描述|
|---|----|---|
| 转换为整数型 | init(float) | 将浮点数的消暑部分删去，转换为整数型|
| | init(bool) | true转换为1，false转换为0|
| 转换为浮点数 | float(init) | 将整数型转换为浮点数(补零)|
| | float(bool) | true转换为1.0，false转换为0.0|
| 转换为布尔值 | bool(init) | 0转换为false，其他为true|
| | bool(float) | 0.0转换为false，其他为true|

### 运算符

GLSL ES支持的运算类型与Javascript类似

进行与(&&)运算时，只有第一个表达式的计算值为true时才会计算第二个表达式。同样，或(||)运算只有第一个表达式为false才会计算第二个。

异或(^^)运算含义是，只有当左右两个表达式中有且仅有一个为true时，运算结果才是true

## 矢量与矩阵

GLSL ES支持矢量和矩阵。他们都包含多个元素，矢量可以表示顶点坐标或颜色值，矩阵用来表示变换矩阵。

| 类别 | GLSL ES数据类型 | 描述|
|---|-------------|---|
| 矢量 | vec2 vec3 vec4 | 具有2 3 4个浮点数元素的矢量|
| | ivec2 ivec3 ivec4 | 具有2 3 4个整型数元素的矢量|
| | bvec2 bvec3 bvec4 | 具有2 3 4个布尔值元素的矢量|
| 矩阵 | mat2 mat3 mat4 | 2\*2 3\*3 4\*4浮点数元素矩阵|

### 赋值和构造

使用=进行赋值操作，=左右两边的变量或值必须一致，矩阵元素个数也必须一致，可以使用内置的构造函数创建对应变量值

### 矢量构造函数

vec() vec2() vec3() vec4()

```
vec3 v3 = vec3(1.0, 0.0, 0.5); // 将v3设置为(1.0, 0.0, 0.5)
vec2 v2 = vec2(vec3); // 使用v3的前两个元素
vec4 v4 = vec4(1.0); // 将v4设置为(1.0, 1.0, 1.0, 1.0)
```
但是，如果构造函数接受了不止一个参数，但是数值参数的个数少于函数需求，那么就会报错。也可以使用多个矢量组合成一个矢量，规则是自前向后依次填充参数矢量的元素，直到填充满，之后截断。

### 矩阵构造函数

和矢量构造函数类似，但需要保证存储在矩阵中的元素是按照列主序排列的。

#### 元素构造

```
mat4 m4 = mat4(
  1.0, 2.0, 3.0, 4.0,
  5.0, 6.0, 7.0, 8.0,
  9.0, 10.0, 11.0, 12.0,
  13.0, 14.0, 15.0, 16.0,
)
// output:
// |1.0 5.0  9.0 13.0|
// |2.0 6.0 10.0 14.0|
// |3.0 7.0 11.0 15.0|
// |4.0 8.0 12.0 16.0|
```

#### 矢量构造

```
// 使用两个vec2对象创建mat2对象
vec2 v2_1 = vec2(1.0, 3.0);
vec2 v2_2 = vec2(2.0, 4.0);
mat2 m2 = mat2(v2_1, v2_2);
// output
// |1.0 2.0|
// |3.0 4.0|

// 使用vec4创建mat2
vec4 v4 = vec4(1.0, 2.0, 3.0, 4.0);
mat2 m2 = mat2(vec4);
// output
// |1.0 3.0|
// |2.0 4.0|
```

#### 混合构造(元素和矢量)

```
// 使用两个浮点数和vec2对象创建mat2
vec2 v2_2 = vec2(2.0, 4.0);
mat2 m2 = mat2(1.0, 3.0, v2_2);
// output
// |1.0 2.0|
// |3.0 4.0|
```

#### 单值构造

```
// 向矩阵构造函数中传入单个数据，这样将生成一个对角线上元素都是该数值，其他元素为0.0
mat2 m2 = mat2(1.0);
// output:
// |1.0 0.0 0.0 0.0|
// |0.0 1.0 0.0 0.0|
// |0.0 0.0 1.0 0.0|
// |0.0 0.0 0.0 1.0|
```

```
// 如果传入的数值数量大于1，又没有达到矩阵元素的数量，就会出错。
mat4 m4 = mat4(1.0, 2.0, 3.0); // 错误，mat4需要16个元素
```

### 访问元素

访问矢量和矩阵的元素，可以使用.和[]

#### 访问矢量元素

在矢量名后接[]运算符通过数组下标访问

在矢量名后接点（.）运算符，然后接上分量名。分量名有:

| 类别 | 描述 |
| --- | --- |
| x,y,z,w | 获取顶点坐标分量 |
| r,g,b,a | 获取颜色分量 |
| s,t,p,q | 获取纹理坐标分量 |

虽然矢量可以用来存储顶点坐标，颜色以及纹理坐标，但事实上，任何矢量的x r s都会返回第一个分量，以此类推，可以随意交换使用它们。

如果试图访问超过矢量长度的分量，会报错。

如果将多个分量共同至于点运算符后，可以抽取出多个分量。混合抽取时，可以省略分量，跳过分量，逆序，重复分量，使用全部分量

```
vec2 v2
v2 = v3.xy // v2为(1.0, 2.0)
v2 = v3.yz // v2为(2.0, 3.0)
```

聚合分量名也可以用=做赋值操作，会修改对应矢量元素

#### 访问矩阵

在矩阵名后接[]运算符通过数组下标访问，矩阵元素仍然是按照列主序读取，一个[]运算符读取矩阵列元素，读取列元素后再接[]运算符读取单个元素。

也可以[]和.运算符混合使用，[]运算符读取咧元素后可以使用上面矩阵分量方式读取单个元素

[]运算符中的索引值必须时常量索引值

1. 整型字面量

2. 用const修饰的全局变量或局部变量

3. 循环索引

4. 由前述三项组成的表达式

```
const init inde x = 0;
vec4 v4a = m4[index]; // 第2条
vec4 v4b = m4[index+1]; // 第4条
```

### 运算符

|运算符 | 运算 | 使用数据类型 |
| ----|----|------- |
| * | 乘法 | 适用于vec[234]和mat[234]，运算结果与操作数一置 |
| / | 除法 | 适用于vec[234]和mat[234]，运算结果与操作数一置 |
| + | 加法 | 适用于vec[234]和mat[234]，运算结果与操作数一置 |
| - | 减法 | 适用于vec[234]和mat[234]，运算结果与操作数一置 |
| ++ | 自增 | 适用于vec[234]和mat[234]，运算结果与操作数一置 |
| -- | 自减 | 适用于vec[234]和mat[234]，运算结果与操作数一置 |
| = | 赋值 | 适用于vec[234]和mat[234] |
| [+|-|*|/]= 运算赋值 | 适用于vec[234]和mat[234] |
| ==,!= | 比较 | 适用于vec[234]和mat[234]。对于==，如果两个操作数的每一个分量都相同，返回true；对于!=，如果两个操作数人和一个分量都不同，返回true |

对于矢量和矩阵，只可以使用比较运算符==和!=。比较矢量和矩阵的大小应该使用内置函数lessThan()等。如果你想逐个分量比较，可以使用内置函数equal()和notEqual()

### 矢量和浮点数运算

将矢量每一个分量与浮点数做运算

```
v3c = v3a + f
// v3b.x = v3a.x + f
// v3b.y = v3a.y + f
// v3b.z = v3a.z + f
```

### 矢量运算

将两个矢量的每一个相同分量做运算

```
v3c = v3a + v3b
// v3a.x + v3b.x
// v3a.y + v3b.y
// v3a.z + v3b.z
```

### 矩阵与浮点数运算

将矩阵的每一个元素和浮点数做运算

### 矩阵与矢量运算


矩阵右乘矢量的结果是矢量，运算方法是将矩阵以行划分，再将矩阵行和矢量对应分量进行矢量浮点数运算。

```
v3b = m3a * v3a;
// v3b.x = m3a[0].x * v3a.x + m3a[1].x * v3a.y + m3a[2].x * v3a.z;
// v3b.y = m3a[0].y * v3a.x + m3a[1].y * v3a.y + m3a[2].y * v3a.z;
// v3b.z = m3a[0].z * v3a.x + m3a[1].z * v3a.y + m3a[2].z * v3a.z;
```

矩阵左乘矢量的结果也是矢量，运算方法是将矩阵以列划分，再将矢量依次和矩阵列进行矢量乘运算。

```
v3b = v3a * m3a;
// v3b.x = m3a[0].x * v3a.x + m3a[0].y * v3a.y + m3a[0].z * v3a.z;
// v3b.y = m3a[1].x * v3a.x + m3a[1].y * v3a.y + m3a[0].z * v3a.z;
// v3b.z = m3a[2].x * v3a.x + m3a[2].y * v3a.y + m3a[2].z * v3a.z;
```

### 矩阵与矩阵运算

矩阵相乘结果为矩阵，运算方法是将被乘矩阵以行划分，乘矩阵以列划分，再将被乘矩阵行和乘矩阵列进行矢量乘运算

## 结构体

用户自定义类型，使用关键字struct，将已存在的类型居合道一起

```
// 定义了结构体类型light
struct light {
  vec4 color
  vec3 position
}
// 声明了light类型的变量I1 I2
light I1,I2
```

### 赋值和构造

结构体有同名的构造函数。构造函数的参数顺序必须与结构体定义中的成员顺序一致。

### 访问

在结构体变量名后跟点运算符再加上成员名

### 运算符

结构体本身只支持赋值(=)和比较(==,!=)

当且仅当两个结构体的变量所对应的所有成员相等时，==才会返回true，如果任意每个成员不相等，!=运算符返回true

### 数组

GLSL ES只支持一维数组，而且数组对象不支持pop()和push()等操作，创建数组不需要使用new，只需要在变量名后架上[]和数组长度，数组长度必须大于0，可以是整型字面量或const限定的变量

```
float floatArray[4]; // 声明含有4个浮点数元素的数组
vec4 vec4Array[2]; // 声明含有2个vec4元素的数组
```

数组不可以在声明时一次性的初始化，必须显式的对每个元素进行初始化。

数组本身只支持[]运算符，单数组的元素能够参与其自身类型支持的任意运算。

### 取样器(纹理)

必须通过该类型才能访问纹理。有两种基础的取样器类型: sampler2D和samperCube。取样器只能为**uniform**变量，或者是要访问纹理的函数。

```
uniform sampler2D u_Sampler
```

唯一能赋值给取样器变量的就是纹理单元编号，而且必须使用WebGL方法gl.uniform1i()。除了=, ==和!=，取样器变量不可以作为操作数参与运算。

取样器变量受到着色器支持的纹理单元的最大数量限制

| 着色器 | 表示最大数量的内置常量 | 最小数量 |
| ----|-------------|----- |
| 顶点着色器 | const mediump int gl_MaxVertexTextureImageUnits | 0 |
| 片元着色器 | const mediump int gl_MaxTextureImageUnits 8 |

## 运算符优先级

|优先级 | 运算符 |
|----|---- |
|1 | 圆括号() |
|2 | 函数调用(),数组索引[],点操作. |
|3 | 自增++,自减--,负-,取反! |
|4 | *,/,% |
|5 | +,- |
|6 | 位移<<, >> |
|7 | 比较<,<=,>,>= |
|8 | 判断==,!= |
|9 | 位与& |
|10 | 位异或^ |
|11 | 位或| |
|12 | 与&& |
|13 | 异或^^ |
|14 | 或|| |
|15 | 三元运算 |
|16 | 运算赋值+=,-=,*=,/=,%=,<<=,>>=,&=,^=,|= |
|17 | 顺序运算符, |

## 程序流程控制

GLSL ES中分支判断和循环和javascript一样，但没有switch语句

## 函数

GLSL ES定义函数的方式更接近于C语言

```
返回类型 函数名 (type arg...) {
  函数计算
  return 返回值;
}
```

参数的type必须指定，函数返回值类型必须指定，无返回值void。调用函数时，参数类型必须与声明时指定的类型一致。

### 规范声明

规范声明会预先告诉WebGL系统函数的参数，参数类型，返回值等

### 参数限定词

为函数参数指定限定词，以控制参数的行为。in是默认限定值。

| 类别 | 规则 | 描述 |
| ----|---|---- |
| in | 向函数传入值 | 参数传入函数，函数内可以使用参数的值，也可以是修改。但是函数内修改不会影响外部 |
| const in | 向函数传入值 | 参数传入函数，函数内可以使用参数的值，但不可以修改。 |
| out | 在函数中被赋值，并被传出 | 传入变量的引用，若其在函数内被修改，会影响到外部 |
| inout | 传入函数，在函数内赋值，并被传出 | 传入变量的引用，可是使用其初始值，若其在函数内被修改，会影响到外部 |

## 内置函数

## 全局变量和局部变量

在CLSL ES中，变量声明在函数外就是全局变量，声明在函数内就是局部变量。

## 存储限定字

### const

const用来限定变量值恒定不变

### attribute

只能出现在顶点着色器中，只能为全局变量，被用来表示**逐顶点**信息。**逐顶点**只存储顶点坐标。

attribute变量类型只能是float, vec2, vec3, vec4, mat2, mat3, mat4

一般情况下，顶点着色器最少支持8个attribute变量

### uniform

uniform可以用在顶点着色器和片元着色器中，只能为全局变量。

uniform变量是只读的，可以是除了数组和结构体之外的任何类型。

如果顶点和片元着色器定义了同名的uniform变量，那将会被两者共享。

uniform应该存储非顶点数据，

### varying

必须为全局变量，用于从顶点着色器向片元着色器传输数据。需要在顶点和片元着色器中定义同名同类型的varying变量。

varying变量类型和attribute一致

顶点着色器赋值给varying变量的值不是直接传递给片元着色器，其中发生了光栅化过程：根据绘制的图形，对前者进行内插，然后在传递给后者。

## 精度限定字

用来表示每种数据的精度。使用精度限定字，你可以精准的控制效果和性能之间的平衡。

webGL支持三种精度值

| 精度限定字 | 描述 | 默认数值范围和精度 |
| ------|----|---------- |
| highp | 高精度，顶点着色器最低精度 | (-2^62, 2^62)精度2^-16 |
| mediump | 中精度，片元着色器最低精度 | (-2^14, 2^14)精度2^-10 |
| lowp | 低精度，可以表示所有颜色 | (-2, 2)精度2^-8 |

数值范围和精度实际上与系统环境相关，可以使用`gl.getShaderPrescisionFormat()`来检查

我们可以使用关键字_precision_来声明着色器的默认精度，必须声明在代码顶部

```
precision 精度限定字 类型名称
```

一般情况我们不需要设置精度，因为着色器已经实现了默认精度，只有片元着色器中的float类型没有。

| 着色器类型 | 数据类型 | 默认精度 |
| ------|------|----- |
| 顶点着色器 | int | highp |
|  | float | highp |
|  | sampler2D | lowp |
|  | samplerCube | lowp |
| 片元着色器 | int | mediump |
|  | float | 无 |
|  | sampler2D | lowp |
|  | samplerCube | lowp |

## 预处理指令

预处理命令用来在真正变异之前对代码进行预处理，都以#开始。

```
#if 条件表达式
表达式为真，执行语句
#endif

#ifdef 某宏
宏已定义，执行语句
#endif

#ifndef 宏
宏未定义，执行语句
#endif
```

### 宏

`#define 宏名 宏内容`定义宏

`#undef 宏名`接触宏定义

宏的名字可以任意，但不能和内置宏名称相同。












